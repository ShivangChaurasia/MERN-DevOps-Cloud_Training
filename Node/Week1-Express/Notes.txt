=====================================================================================
# Express.js Notes
=====================================================================================
## What is Express.js?

Express.js, or simply Express, is a minimal and flexible **Node.js web application framework**. It's the most popular framework for Node.js and is a key component of the **MERN stack** (MongoDB, Express.js, React.js, Node.js).

Think of it as a layer built on top of the core Node.js `http` module to make building web applications and APIs much easier and more organized. While you *can* build a web server with just Node.js, Express provides a robust set of features that simplifies the process significantly.

### Core Features

*   **Routing:** It provides a simple yet powerful routing system to handle different HTTP requests (GET, POST, PUT, DELETE, etc.) at different URL paths.
*   **Middleware:** This is one of the most important concepts in Express. Middleware functions are functions that have access to the request object (`req`), the response object (`res`), and the `next` function in the applicationâ€™s request-response cycle. They can execute code, make changes to the request and the response objects, end the request-response cycle, and call the next middleware in the stack. This is used for tasks like logging, authentication, parsing request bodies, and more.
*   **Template Engines:** It allows you to use template engines like Pug, EJS, or Handlebars to dynamically generate HTML.
*   **Focus on Performance:** Express provides a thin layer of fundamental web application features, without obscuring Node.js features that you know and love.

### Example: A Simple "Hello World" Server

Here is the code to create a simple server that sends "Hello World!" when you visit it in your browser.

```javascript
// 1. Import the express library
const express = require('express');

// 2. Create an instance of an Express application
const app = express();

// 3. Define the port the server will run on
const port = 3000;

// 4. Define a route for the root URL ('/')
// When a GET request is made to the root, this function will be called
app.get('/', (req, res) => {
  res.send('Hello World!');
});

// 5. Start the server and have it listen on the specified port
app.listen(port, () => {
  console.log(`Example app listening at http://localhost:${port}`);
});
```

**To run this example:**

1.  You would need to have Node.js and npm installed.
2.  You would need to install Express.js by running `npm install express` in your terminal in the project directory.
3.  You can then run the server with the command `node index.js`.
4.  Finally, you can open your web browser and navigate to `http://localhost:3000` to see "Hello World!".

-----------------------------------------------------------------------------------------------------


===============================================================================================
## Middleware and its Types
===============================================================================================

### What is Middleware?

In the context of Express.js, **middleware** refers to functions that have access to the **request object (`req`)**, the **response object (`res`)**, and the **`next` function** in the application's request-response cycle. These functions sit in a chain between the incoming request and the final route handler.

When a request hits your server, it passes through a series of middleware functions in the order they are defined. Each middleware can perform operations and then has two choices:

1.  **End the cycle:** Send a response back to the client (e.g., `res.send()`, `res.json()`, `res.sendFile()`).
2.  **Pass control to the next middleware:** Call the `next()` function to move the request along the chain to the next middleware or route handler.

If a middleware function doesn't end the cycle or call `next()`, the request will be left "hanging," and the client will eventually time out.

**Key tasks performed by middleware include:**

*   Executing any code.
*   Making changes to the request and response objects (e.g., adding user information to `req`).
*   Logging request details for debugging or analytics.
*   Parsing the body of incoming requests (e.g., JSON or URL-encoded data).
*   Authenticating and authorizing users.
*   Handling errors.

### Types of Middleware in Express

Express.js has five main types of middleware:

#### 1. Application-level Middleware

This middleware is bound to the main application object (`app`) using `app.use()` or `app.METHOD()` (where `METHOD` is an HTTP verb like `get`, `post`, etc.).

*   **`app.use()`:** Used to apply middleware to all requests, or to requests that match a specific path.

    ```javascript
    const app = express();

    // A simple logger middleware that runs for every request
    app.use((req, res, next) => {
      console.log(`Request received at: ${Date.now()}`);
      next(); // Pass control to the next middleware
    });

    app.get('/', (req, res) => {
      res.send('Homepage');
    });
    ```

#### 2. Router-level Middleware

This works exactly like application-level middleware but is bound to an instance of `express.Router()`. It's used to create modular and mountable route handlers.

```javascript
const express = require('express');
const app = express();
const router = express.Router();

// Middleware for this specific router
router.use((req, res, next) => {
  console.log('Time:', Date.now());
  next();
});

// A route on this router
router.get('/user/:id', (req, res) => {
  res.send(`User ID: ${req.params.id}`);
});

// Mount the router on the '/admin' path
app.use('/admin', router);
```

#### 3. Error-handling Middleware

This is a special type of middleware that has **four arguments** instead of three: `(err, req, res, next)`. It's used to catch and process errors that occur in your application. It must be defined *after* all other `app.use()` and route calls.

```javascript
app.get('/error', (req, res, next) => {
  // Create an error and pass it to the next function
  const err = new Error('This is a simulated error.');
  next(err);
});

// Error-handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
```

#### 4. Built-in Middleware

Express comes with several useful middleware functions built-in:

*   `express.json()`: Parses incoming requests with JSON payloads.
*   `express.urlencoded({ extended: true })`: Parses incoming requests with URL-encoded payloads.
*   `express.static('public')`: Serves static files (like images, CSS, and JavaScript) from a directory.

```javascript
const express = require('express');
const app = express();

// Serve static files from the 'public' directory
app.use(express.static('public'));

// Parse JSON bodies
app.use(express.json());

app.post('/api/data', (req, res) => {
  console.log(req.body); // The parsed JSON data
  res.json({ status: 'success', data: req.body });
});
```

#### 5. Third-party Middleware

These are packages you can install from npm to add functionality to your Express application. Examples include:

*   **`morgan`**: An HTTP request logger.
*   **`cors`**: Enables Cross-Origin Resource Sharing.
*   **`helmet`**: Helps secure your app by setting various HTTP headers.
*   **`cookie-parser`**: Parses `Cookie` header and populates `req.cookies`.

```bash
npm install morgan
```

```javascript
const express = require('express');
const morgan = require('morgan');
const app = express();

// Use morgan for request logging in the 'dev' format
app.use(morgan('dev'));

app.get('/', (req, res) => {
  res.send('Hello World!');
});
```
============================================================================================================================================================================
------------------------------------------------------------------------------------------React Notes-----------------------------------------------------------------------------
============================================================================================================================================================================

What is React?
React is a JavaScript library for building user interfaces, particularly single-page (SPA) applications where you need a
fast, interactive user experience. It allows developers to create large web applications that can update and render efficiently in response to data changes.
Uses virtual DOM concept to optimize rendering performance by minimizing direct manipulation of the actual DOM.

Declarative vs Imperative:
Declarative programming is a style of building programs that expresses the logic of computation without describing its control flow. 
In contrast, imperative programming requires developers to explicitly define the steps the computer must take to achieve a desired outcome.
React follows the declarative programming paradigm, allowing developers to describe what the UI should look like for a given state,
and React takes care of updating the DOM to match that state.
Table:
| Aspect               | Declarative Programming                     | Imperative Programming                      |
|----------------------|---------------------------------------------|---------------------------------------------|
| Focus                | What the program should accomplish          | How the program should accomplish it        |
| Control Flow        | Abstracted away, handled by the framework   | Explicitly defined by the developer         |
| Readability         | Generally more readable and easier to understand | Can be harder to read due to detailed control flow  |
| Maintenance        | Easier to maintain and refactor             | Can become complex and harder to maintain over time |
---------------------------------------------------------------------------------------------------------------------------------


Library vs Framework:
A library is a collection of pre-written code that developers can use to optimize tasks. It provides specific functionality that can be called upon as needed.
A framework, on the other hand, is a more comprehensive solution that provides a structure for building applications. It often dictates the architecture and flow of the application.
React is considered a library because it focuses specifically on building user interfaces and does not impose a specific architecture on the application.

Is React a framework or a library?
React is a library, not a framework. It is primarily concerned with the view layer of an application and does not provide a
full-fledged framework for building applications like Angular or Vue.js.
Table:
| Aspect               | Library                                    | Framework                                   |
|----------------------|---------------------------------------------|---------------------------------------------|
| Control              | Developer calls the library as needed      | Framework calls the developer's code         |
| Scope                | Focused on specific functionality          | Provides a complete structure for applications|
| Flexibility         | More flexible, can be integrated with other libraries | Less flexible, often requires adherence to its structure |
| Learning Curve      | Generally easier to learn due to focused scope | Can be steeper due to comprehensive nature          |
---------------------------------------------------------------------------------------------------------------------------------


SSR (Server-Side Rendering) vs CSR (Client-Side Rendering):
SSR (Server-Side Rendering) is a technique where the server generates the full HTML for a page and sends it to the client.
CSR (Client-Side Rendering) is a technique where the client (browser) generates the HTML for a page using JavaScript after the initial page load.
Table:
| Aspect               | Server-Side Rendering (SSR)                               | Client-Side Rendering (CSR)                 |
|----------------------|-----------------------------------------------------------|---------------------------------------------|
| Initial Load Time   | Faster initial load, as HTML is pre-rendered on the server | Slower initial load, as HTML is generated on the client |
| SEO                 | Better for SEO, as content is available in the initial HTML | Can be less SEO-friendly, as content is generated via JavaScript |
| Interactivity      | May require additional client-side JavaScript for interactivity | Interactivity is built-in as the client generates the HTML |
| Server Load        | Higher server load, as server generates HTML for each request | Lower server load, as client handles rendering after initial load |
---------------------------------------------------------------------------------------------------------------------------------


Babel:-------------------------------------------------------------------
Babel is a JavaScript compiler that allows developers to write modern JavaScript code
(ES6 and beyond) and transpile it into a version of JavaScript that is compatible with older browsers.

Examples of features Babel can transpile:
1. Arrow Functions
2. Classes
3. Template Literals
4. Destructuring Assignment
5. Modules (import/export)

Example Code for inseting cdn & using babel:
<!DOCTYPE html>
<html>
<head>
    <title>Babel Example</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="app"></div>
    <script type="text/babel">
        const greet = (name) => {
            console.log(`Hello, ${name}!`);
        };
        greet('World');

        //OR

        const root = ReactDOM.createRoot(document.getElementById('app'))
        let bab = <h1>This is H1 Tag</h1> // Babel Used
        root.render(bab)'

        //OR
        function Greet(){
        return(
                <div>
                    <h1>Good Morning!</h1>
                </div>
            );
        }
root.render(<Greet></Greet>)

    </script>
</body>
</html>


Example of Transpilation:
// ES6+ code
const greet = (name) => {
    console.log(`Hello, ${name}!`);
};
// Transpiled ES5 code
var greet = function(name) {
    console.log('Hello, ' + name + '!');
};

----------------------------------------------------------------------------------------
Concepts of React:
----------------------------------------------------------------------------------------
Components:
Components are the building blocks of a React application. They are reusable, self-contained pieces of code that define how a certain part of the UI should appear and behave.
Components can be functional or class-based, with functional components being the more modern and preferred approach in recent React development.

----------------------------------------------------------------------------------------
JSX (JavaScript XML):
JSX is a syntax extension for JavaScript that looks similar to HTML. It allows developers to write HTML-like code within JavaScript, making it easier to create and visualize the structure of the UI.
JSX is transpiled to regular JavaScript by tools like Babel before being executed in the browser

----------------------------------------------------------------------------------------
Props:
Props (short for "properties") are a way to pass data from a parent component to a child component in React. They are read-only and allow components to be reusable and dynamic.
Example of using props:
function Greeting(props) {
    return <h1>Hello, {props.name}!</h1>;
}
In this example, the Greeting component takes a prop called "name" and uses it to display a personalized greeting message. When rendering the Greeting component, you can pass a value for the "name" prop like this:
<Greeting name="Alice" />

----------------------------------------------------------------------------------------
Hooks in React:
Hooks are functions that allow you to use state and other React features in functional components. They were introduced in React 16.8 to enable developers to manage state and side effects without needing to write class components.
Some commonly used hooks include:
1. useState: Allows you to add state to functional components.
2. useEffect: Allows you to perform side effects in functional components, such as fetching data or subscribing to events.
3. useContext: Allows you to access the context API in functional components.
4. useRef: Allows you to create a mutable reference that persists across renders.
----------------------------------------------------------------------------------------
State:
State is a built-in object in React that allows components to manage and update their own data. Unlike props, state is mutable and can be changed over time, typically in response to user actions or other events.
Example of using state in a functional component with the useState hook:
import React, { useState } from 'react';
function Counter() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={() => setCount(count + 1)}>
                Click me
            </button>
        </div>
    );
}

-----------------------------------------------------------------------------------------

useEffect:
The useEffect hook is a function in React that allows you to perform side effects in functional components
. It serves a similar purpose to lifecycle methods in class components, such as componentDidMount, componentDidUpdate, and componentWillUnmount.
Example of using useEffect to fetch data from an API when a component mounts:
import React, { useState, useEffect } from 'react';
function DataFetcher() {
    const [data, setData] = useState(null);

    useEffect(() => {
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data));
    }, []); // Empty dependency array means this effect runs once on mount

    return (
        <div>
            {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : 'Loading...'}
        </div>
    );
}

Example of using useState and useEffect together:
import React, { useState, useEffect } from 'react';
function Timer() {
    const [seconds, setSeconds] = useState(0);

    useEffect(() => {
        const interval = setInterval(() => {
            setSeconds(prevSeconds => prevSeconds + 1);
        }, 1000);
        return () => clearInterval(interval); // Cleanup on unmount
    }, []); // Empty dependency array means this effect runs once on mount

    return <div>Seconds: {seconds}</div>;
}
------------------------------------------------------------------------------------------

Forms in React:
In React, forms are typically handled using controlled components, where the form data is managed by the
component's state. This allows for more control over the form inputs and makes it easier to handle user input and form submission.
Example of a controlled form component:
import React, { useState } from 'react';
function MyForm() {
    const [name, setName] = useState('');

    const handleSubmit = (event) => {
        event.preventDefault();
        alert(`Submitted name: ${name}`);
    };

    return (
        <form onSubmit={handleSubmit}>
            <label>
                Name:
                <input
                    type="text"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                />
            </label>
            <button type="submit">Submit</button>
        </form>
    );
}
In this example, the input field is a controlled component because its value is controlled by the React state (the "name" variable). The onChange event updates the state whenever the user types in the input field, and the handleSubmit function is called when the form is submitted, preventing the default form submission behavior and displaying an alert with the submitted name.
----------------------------------------------------------------------------------------------------------------


Task: //Create Form in React-------------------- use local storage of browser
-------------------------------------------------------------------------


=============================================
Fetch Method in React using fetch() without useEffect:
=============================================

The fetch() method is a built-in JavaScript function that allows you to make network requests to retrieve resources from a server. In React, you can use the fetch() 
method to fetch data from an API and update your component's state with the retrieved data.
Example of using fetch() in a React component:
import React, { useState } from 'react';
function DataFetcher() {
    const [data, setData] = useState(null);

    const fetchData = () => {
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data))
            .catch(error => console.error('Error fetching data:', error));
    };

    return (
        <div>
            <button onClick={fetchData}>Fetch Data</button>
            {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
        </div>
    );
}

In this example, the fetchData function is called when the "Fetch Data" button is clicked. It uses the fetch() method to make a GET request to the specified API endpoint.
The response is then converted to JSON and stored in the component's state using setData. If there is an error during the fetch operation, it is caught and logged to the console.
The retrieved data is displayed in a formatted manner using JSON.stringify when it is available.


==========================
Adding Data---------
==========================
import React, { useState } from 'react';
function AddData() {
    const [name, setName] = useState('');
    const [age, setAge] = useState('');

    const handleSubmit = (event) => {
        event.preventDefault();
        const newData = { name, age };
        // Here you can send newData to an API or update your state
        console.log('New Data:', newData);
    };

    return (
        <form onSubmit={handleSubmit}>
            <label>
                Name:
                <input
                    type="text"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                />
            </label>
            <br />
            <label>
                Age:
                <input
                    type="number"
                    value={age}
                    onChange={(e) => setAge(e.target.value)}
                />
            </label>
            <br />
            <button type="submit">Add Data</button>
        </form>
    );
}

In this example, we have a form with two input fields for "name" and "age". The handleSubmit function is called when the form is submitted,
preventing the default form submission behavior.
It creates a new data object with the values from the input fields and logs it to the console.
You can modify the handleSubmit function to send this data to an API or update your component's state as needed.
----------------------------------------------------------------------------------------------------------------------------------

=======================================================================
Axios in React:
=======================================================================

Axios is a popular JavaScript library used for making HTTP requests from the browser. It provides a simple and intuitive API for sending asynchronous requests to a server and handling responses.
Example of using Axios in a React component:
import React, { useState } from 'react';
import axios from 'axios';
function DataFetcher() {
    const [data, setData] = useState(null);

    const fetchData = () => {
        axios.get('https://api.example.com/data')
            .then(response => setData(response.data))
            .catch(error => console.error('Error fetching data:', error));
    };

    return (
        <div>
            <button onClick={fetchData}>Fetch Data</button>
            {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
        </div>
    );
}
In this example, we import the Axios library and use it to make a GET request to the specified API endpoint when the "Fetch Data" button is clicked.
The response data is stored in the component's state using setData, and any errors during the request are caught and logged to the console. The retrieved data is displayed in a formatted manner using JSON.stringify when it is available.

Example of using Axios to send a POST request:
import React, { useState } from 'react';
import axios from 'axios';
function AddData() {
    const [name, setName] = useState('');
    const [age, setAge] = useState('');

    const handleSubmit = (event) => {
        event.preventDefault();
        const newData = { name, age };
        axios.post('https://api.example.com/data', newData)
            .then(response => console.log('Data added:', response.data))
            .catch(error => console.error('Error adding data:', error));
    };

    return (
        <form onSubmit={handleSubmit}>
            <label>
                Name:
                <input
                    type="text"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                />
            </label>
            <br />
            <label>
                Age:
                <input
                    type="number"
                    value={age}
                    onChange={(e) => setAge(e.target.value)}
                />
            </label>
            <br />
            <button type="submit">Add Data</button>
        </form>
    );
}

In this example, we use Axios to send a POST request to the specified API endpoint with the new data object when the form is submitted.
The response from the server is logged to the console, and any errors during the request are also caught and logged.

-----------------------------------------------------------------------------------------------------------------------------------

=====================================================================
Lifecycle Methods in React: It is of three types.
=====================================================================

Lifecycle methods are special methods in React class components that allow you to hook into different stages of a component's lifecycle, such as when
it is mounted, updated, or unmounted. These methods provide a way to perform side effects, manage state, and interact with the DOM at specific points in the component's lifecycle.

Some commonly used lifecycle methods include:
1. componentDidMount: Called immediately after a component is mounted (inserted into the tree).
    You can use this method to perform initialization tasks, such as fetching data from an API or setting up event listeners.

2. componentDidUpdate: Called immediately after updating occurs. This method is not called for the initial render.
    You can use this method to perform operations after the component has been updated, such as updating the DOM or making additional API calls based on changes in props or state.

3. componentWillUnmount: Called immediately before a component is unmounted and destroyed.
    You can use this method to perform cleanup tasks, such as removing event listeners or canceling network requests.

    Example of using lifecycle methods in a React class component:
    import React, { Component } from 'react';
    class MyComponent extends Component {
        componentDidMount() {
            console.log('Component has mounted');
            // Perform initialization tasks here
        }

        componentDidUpdate(prevProps, prevState) {
            console.log('Component has updated');
            // Perform operations after the component has been updated
        }

        componentWillUnmount() {
            console.log('Component will unmount');
            // Perform cleanup tasks here
        }

        render() {
            return <div>Hello, World!</div>;
        }
    }

In this example, we define a class component called MyComponent that implements the three lifecycle methods: componentDidMount, componentDidUpdate, and componentWillUnmount.

---------------------------------------------------------------------------------------------------

======================================
Side Effects in React:
======================================

In React, side effects refer to any operations that can affect the state of the application or interact with external systems, such as fetching data from an API, manipulating the DOM, or setting up event listeners.
React provides the useEffect hook to handle side effects in functional components. The useEffect hook allows
you to perform side effects in a way that is consistent with the component's lifecycle, ensuring that effects are properly cleaned up when the component unmounts or when dependencies change.
Example of using useEffect to perform a side effect:
import React, { useState, useEffect } from 'react';
function DataFetcher() {
    const [data, setData] = useState(null);

    useEffect(() => {
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data))
            .catch(error => console.error('Error fetching data:', error));
    }, []); // Empty dependency array means this effect runs once on mount

    return (
        <div>
            {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : 'Loading...'}
        </div>
    );
}

Ex:- 
    1. Fetching data from an API when a component mounts, setting up a timer that updates the state every second, or adding event listeners to handle user interactions are all examples of side effects in React. 
    The useEffect hook allows you to manage these side effects in a way that is consistent with the component's lifecycle, ensuring that they are properly cleaned up when necessary.

    2. Updating the browser's document title based on the component's state is another common example of a side effect in React. You can use the useEffect hook to achieve this as follows:
        import React, { useState, useEffect } from 'react';
        function DocumentTitleUpdater() {
            const [count, setCount] = useState(0);

            useEffect(() => {
                document.title = `Count: ${count}`;
            }, [count]); // This effect runs whenever the 'count' state changes

            return (
                <div>
                    <p>Count: {count}</p>
                    <button onClick={() => setCount(count + 1)}>Increment</button>
                </div>
            );
        }

    3. Setting timeouts or intervals to perform actions after a certain period of time is also a common side effect in React. You can use the useEffect hook to manage these timers and ensure they are cleaned up properly:
        import React, { useState, useEffect } from 'react';
        function Timer() {
            const [seconds, setSeconds] = useState(0);

            useEffect(() => {
                const interval = setInterval(() => {
                    setSeconds(prevSeconds => prevSeconds + 1);
                }, 1000);
                return () => clearInterval(interval); // Cleanup on unmount
            }, []); // Empty dependency array means this effect runs once on mount

            return <div>Seconds: {seconds}</div>;
        }

    4. Adding event listeners to handle user interactions, such as scrolling or resizing the window, is another example of a side effect in React. You can use the useEffect hook to manage these event listeners and ensure they are cleaned up when the component unmounts:
        import React, { useState, useEffect } from 'react';
        function WindowSize() {
            const [windowWidth, setWindowWidth] = useState(window.innerWidth);

            useEffect(() => {
                const handleResize = () => setWindowWidth(window.innerWidth);
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize); // Cleanup on unmount
            }, []); // Empty dependency array means this effect runs once on mount

            return <div>Window width: {windowWidth}px</div>;
        }

    5. Manipulating the DOM directly, such as focusing an input field when a component mounts, is also considered a side effect in React. You can use the useEffect hook to perform this action:
        import React, { useRef, useEffect } from 'react';
        function FocusInput() {
            const inputRef = useRef(null);

            useEffect(() => {
                inputRef.current.focus(); // Focus the input field when the component mounts
            }, []); // Empty dependency array means this effect runs once on mount

            return <input ref={inputRef} type="text" placeholder="Focus me!" />;
        }

    6. Interacting with external systems, such as sending analytics data or integrating with third-party libraries, is also a common example of a side effect in React.
    You can use the useEffect hook to manage these interactions and ensure they are performed at the appropriate times in the component's lifecycle.
        import React, { useEffect } from 'react';
        function AnalyticsTracker() {
            useEffect(() => {
                // Send analytics data when the component mounts
                sendAnalyticsData('Component Mounted');
                return () => {
                    // Send analytics data when the component unmounts
                    sendAnalyticsData('Component Unmounted');
                };
            }, []); // Empty dependency array means this effect runs once on mount

            return <div>Tracking analytics...</div>;
        }

        function sendAnalyticsData(message) {
            console.log(`Analytics: ${message}`);
            // Here you would typically send this data to an analytics service
        }


    7. Performing cleanup tasks, such as canceling network requests or removing event listeners when a component unmounts, is also an important aspect of managing side effects in React. The useEffect hook allows you to return a cleanup function that will be called when the component unmounts or when dependencies change:
        import React, { useEffect } from 'react';
        function CleanupExample() {
            useEffect(() => {
                const handleScroll = () => console.log('Scrolled!');
                window.addEventListener('scroll', handleScroll);
                return () => window.removeEventListener('scroll', handleScroll); // Cleanup on unmount
            }, []); // Empty dependency array means this effect runs once on mount

            return <div>Scroll the window to see the effect!</div>;
        }

--------------------------------------------------------------------------------------------------

==============================================================================================================================
Context API in React:
==============================================================================================================================

The Context API in React is a way to manage and share state across a component tree without having to pass props down manually at every level.
It provides a way to create global state that can be accessed by any component in the tree, regardless of how deeply nested it is.

Example of using the Context API in React:
import React, { createContext, useState, useContext } from 'react';
// Create a Context
const MyContext = createContext();
// Create a Provider component
function MyProvider({ children }) {
    const [value, setValue] = useState('Hello, World!');
    return (
        <MyContext.Provider value={{ value, setValue }}>
            {children}
        </MyContext.Provider>
    );
}


// Create a component that consumes the Context
function MyComponent() {
    const { value, setValue } = useContext(MyContext);
    return (
        <div>
            <p>{value}</p>
            <button onClick={() => setValue('Hello, React!')}>Change Value</button>
        </div>
    );
}

// Use the Provider to wrap the component tree
function App() {
    return (    
        <MyProvider>
            <MyComponent />
        </MyProvider>
    );
}

In this example, we create a Context called MyContext and a Provider component called MyProvider that uses the useState hook to manage a piece of state called "value". 
The Provider component wraps the children components and provides the value and setValue function through the Context.


Benefits of using the Context API:
1. Avoids Prop Drilling: The Context API allows you to share state across the component tree without having to pass props down manually at every level, 
which can help avoid "prop drilling" and make your code cleaner and easier to maintain.
2. Global State Management: The Context API provides a way to create global state that can be accessed by any component in the tree, 
making it easier to manage state that needs to be shared across multiple components.
3. Improved Performance: By using the Context API, you can avoid unnecessary re-renders of components that do not need to access the shared state, which can improve the performance of your application.
4. Better Code Organization: The Context API allows you to organize your code in a way that makes it clear which components are consuming the shared state, which can improve the readability and maintainability of your code.


Example of using the Context API to manage theme state in a React application:
import React, { createContext, useState, useContext } from 'react';

// Create a Context for the theme
const ThemeContext = createContext();
// Create a Provider component for the theme
function ThemeProvider({ children }) {
    const [theme, setTheme] = useState('light');
    return (
        <ThemeContext.Provider value={{ theme, setTheme }}>
            {children}
        </ThemeContext.Provider>
    );
}

// Create a component that consumes the ThemeContext
function ThemeToggler() {
    const { theme, setTheme } = useContext(ThemeContext);
    return (
        <div>
            <p>Current theme: {theme}</p>
            <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
                Toggle Theme
            </button>
        </div>
    );
}

// Use the ThemeProvider to wrap the component tree
function App() {
    return (
        <ThemeProvider>
            <ThemeToggler />
        </ThemeProvider>
    );
}


---------------------------------------------------------------------------------------------------
================================================================================================================
Routing in React:
================================================================================================================

Routing in React is the process of managing navigation between different views or pages in a React application.
React Router is a popular library for handling routing in React applications. It allows you to define routes
and navigate between them without causing a full page refresh, providing a seamless user experience.

Example of using React Router for routing in a React application:
import React from 'react';
import { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';
function Home() {
    return <h1>Home Page</h1>;
}
function About() {
    return <h1>About Page</h1>;
}
function App() {
    return (
        <Router>
            <nav>
                <ul>
                    <li><Link to="/">Home</Link></li>
                    <li><Link to="/about">About</Link></li>
                </ul>
            </nav>
            <Switch>
                <Route exact path="/" component={Home} />
                <Route path="/about" component={About} />
            </Switch>
        </Router>
    );
}
In this example, we use the BrowserRouter component to wrap our application and enable routing. We define two routes: one for the home page ("/") and one for the about page ("/about").
The Link component is used to create navigation links that allow users to navigate between the different routes without causing a full page refresh. The Switch component is used to render the first matching route, ensuring that only one route is rendered at a time.


Benefits of using React Router for routing in React applications:
1. Declarative Routing: React Router allows you to define your routes in a declarative way, making it easier to understand and manage the navigation structure of your application.

2. Dynamic Routing: React Router supports dynamic routing, allowing you to create routes that can change based on user input or other factors, providing a more flexible navigation experience.

3. Nested Routes: React Router allows you to create nested routes, enabling you to build complex
navigation structures within your application while keeping your code organized and maintainable.

4. Route Parameters: React Router supports route parameters, allowing you to capture dynamic values from the
URL and use them in your components, which can be useful for creating dynamic pages or handling user input.

5. Integration with React: React Router is designed to work seamlessly with React, allowing you to
easily integrate routing into your React applications without needing to worry about the underlying implementation details of navigation and URL management.


Example of using React Router to create a simple blog application with dynamic routes for individual blog posts:
import React from 'react';
import { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';
function Home() {
    return (
        <div>
            <h1>Home Page</h1>
            <ul>
                <li><Link to="/post/1">Blog Post 1</Link></li>
                <li><Link to="/post/2">Blog Post 2</Link></li>
                <li><Link to="/post/3">Blog Post 3</Link></li>
            </ul>
        </div>
    );
}
function Post({ match }) {
    const postId = match.params.id;
    return <h1>Blog Post {postId}</h1>;
}
function App() {
    return (
        <Router>
            <Switch>
                <Route exact path="/" component={Home} />
                <Route path="/post/:id" component={Post} />
            </Switch>
        </Router>
    );
}
In this example, we have a Home component that displays a list of blog posts with links to individual post pages. The Post component uses route parameters to capture the dynamic post ID from the URL and display it in the heading. The React Router setup allows for seamless navigation between the home page and individual blog post pages without causing a full page refresh.

Anchor <a></a> vs Link <Link></Link> in React Router:
1. Anchor <a></a>:
- The anchor tag is a standard HTML element used for creating hyperlinks. When you click on an anchor tag, it causes a full page refresh as the browser navigates to the new URL.
Example:
<a href="/about">About</a>

2. Link <Link></Link>:
- The Link component is provided by React Router and is used to create navigation links in a React
    application. When you click on a Link component, it prevents the default browser behavior of causing a full page refresh and instead updates the 
    URL and renders the new component without refreshing the page.
Example:
<Link to="/about">About</Link>

-----------------------------------------------------------------------------------------------------------------------










============================================================================================================================================================================
------------------------------------------------------------------------------------------React Notes-----------------------------------------------------------------------------
============================================================================================================================================================================

What is React?
React is a JavaScript library for building user interfaces, particularly single-page (SPA) applications where you need a
fast, interactive user experience. It allows developers to create large web applications that can update and render efficiently in response to data changes.
Uses virtual DOM concept to optimize rendering performance by minimizing direct manipulation of the actual DOM.

Declarative vs Imperative:
Declarative programming is a style of building programs that expresses the logic of computation without describing its control flow. 
In contrast, imperative programming requires developers to explicitly define the steps the computer must take to achieve a desired outcome.
React follows the declarative programming paradigm, allowing developers to describe what the UI should look like for a given state,
and React takes care of updating the DOM to match that state.
Table:
| Aspect               | Declarative Programming                     | Imperative Programming                      |
|----------------------|---------------------------------------------|---------------------------------------------|
| Focus                | What the program should accomplish          | How the program should accomplish it        |
| Control Flow        | Abstracted away, handled by the framework   | Explicitly defined by the developer         |
| Readability         | Generally more readable and easier to understand | Can be harder to read due to detailed control flow  |
| Maintenance        | Easier to maintain and refactor             | Can become complex and harder to maintain over time |
---------------------------------------------------------------------------------------------------------------------------------


Library vs Framework:
A library is a collection of pre-written code that developers can use to optimize tasks. It provides specific functionality that can be called upon as needed.
A framework, on the other hand, is a more comprehensive solution that provides a structure for building applications. It often dictates the architecture and flow of the application.
React is considered a library because it focuses specifically on building user interfaces and does not impose a specific architecture on the application.

Is React a framework or a library?
React is a library, not a framework. It is primarily concerned with the view layer of an application and does not provide a
full-fledged framework for building applications like Angular or Vue.js.
Table:
| Aspect               | Library                                    | Framework                                   |
|----------------------|---------------------------------------------|---------------------------------------------|
| Control              | Developer calls the library as needed      | Framework calls the developer's code         |
| Scope                | Focused on specific functionality          | Provides a complete structure for applications|
| Flexibility         | More flexible, can be integrated with other libraries | Less flexible, often requires adherence to its structure |
| Learning Curve      | Generally easier to learn due to focused scope | Can be steeper due to comprehensive nature          |
---------------------------------------------------------------------------------------------------------------------------------


SSR (Server-Side Rendering) vs CSR (Client-Side Rendering):
SSR (Server-Side Rendering) is a technique where the server generates the full HTML for a page and sends it to the client.
CSR (Client-Side Rendering) is a technique where the client (browser) generates the HTML for a page using JavaScript after the initial page load.
Table:
| Aspect               | Server-Side Rendering (SSR)                               | Client-Side Rendering (CSR)                 |
|----------------------|-----------------------------------------------------------|---------------------------------------------|
| Initial Load Time   | Faster initial load, as HTML is pre-rendered on the server | Slower initial load, as HTML is generated on the client |
| SEO                 | Better for SEO, as content is available in the initial HTML | Can be less SEO-friendly, as content is generated via JavaScript |
| Interactivity      | May require additional client-side JavaScript for interactivity | Interactivity is built-in as the client generates the HTML |
| Server Load        | Higher server load, as server generates HTML for each request | Lower server load, as client handles rendering after initial load |
---------------------------------------------------------------------------------------------------------------------------------


Babel:-------------------------------------------------------------------
Babel is a JavaScript compiler that allows developers to write modern JavaScript code
(ES6 and beyond) and transpile it into a version of JavaScript that is compatible with older browsers.

Examples of features Babel can transpile:
1. Arrow Functions
2. Classes
3. Template Literals
4. Destructuring Assignment
5. Modules (import/export)

Example Code for inseting cdn & using babel:
<!DOCTYPE html>
<html>
<head>
    <title>Babel Example</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="app"></div>
    <script type="text/babel">
        const greet = (name) => {
            console.log(`Hello, ${name}!`);
        };
        greet('World');

        //OR

        const root = ReactDOM.createRoot(document.getElementById('app'))
        let bab = <h1>This is H1 Tag</h1> // Babel Used
        root.render(bab)'

        //OR
        function Greet(){
        return(
                <div>
                    <h1>Good Morning!</h1>
                </div>
            );
        }
root.render(<Greet></Greet>)

    </script>
</body>
</html>


Example of Transpilation:
// ES6+ code
const greet = (name) => {
    console.log(`Hello, ${name}!`);
};
// Transpiled ES5 code
var greet = function(name) {
    console.log('Hello, ' + name + '!');
};

----------------------------------------------------------------------------------------
Concepts of React:
----------------------------------------------------------------------------------------
Components:
Components are the building blocks of a React application. They are reusable, self-contained pieces of code that define how a certain part of the UI should appear and behave.
Components can be functional or class-based, with functional components being the more modern and preferred approach in recent React development.

----------------------------------------------------------------------------------------
JSX (JavaScript XML):
JSX is a syntax extension for JavaScript that looks similar to HTML. It allows developers to write HTML-like code within JavaScript, making it easier to create and visualize the structure of the UI.
JSX is transpiled to regular JavaScript by tools like Babel before being executed in the browser

----------------------------------------------------------------------------------------
Props:
Props (short for "properties") are a way to pass data from a parent component to a child component in React. They are read-only and allow components to be reusable and dynamic.
Example of using props:
function Greeting(props) {
    return <h1>Hello, {props.name}!</h1>;
}
In this example, the Greeting component takes a prop called "name" and uses it to display a personalized greeting message. When rendering the Greeting component, you can pass a value for the "name" prop like this:
<Greeting name="Alice" />

----------------------------------------------------------------------------------------
Hooks in React:
Hooks are functions that allow you to use state and other React features in functional components. They were introduced in React 16.8 to enable developers to manage state and side effects without needing to write class components.
Some commonly used hooks include:
1. useState: Allows you to add state to functional components.
2. useEffect: Allows you to perform side effects in functional components, such as fetching data or subscribing to events.
3. useContext: Allows you to access the context API in functional components.
4. useRef: Allows you to create a mutable reference that persists across renders.
----------------------------------------------------------------------------------------
State:
State is a built-in object in React that allows components to manage and update their own data. Unlike props, state is mutable and can be changed over time, typically in response to user actions or other events.
Example of using state in a functional component with the useState hook:
import React, { useState } from 'react';
function Counter() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={() => setCount(count + 1)}>
                Click me
            </button>
        </div>
    );
}

-----------------------------------------------------------------------------------------

useEffect:
The useEffect hook is a function in React that allows you to perform side effects in functional components
. It serves a similar purpose to lifecycle methods in class components, such as componentDidMount, componentDidUpdate, and componentWillUnmount.
Example of using useEffect to fetch data from an API when a component mounts:
import React, { useState, useEffect } from 'react';
function DataFetcher() {
    const [data, setData] = useState(null);

    useEffect(() => {
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data));
    }, []); // Empty dependency array means this effect runs once on mount

    return (
        <div>
            {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : 'Loading...'}
        </div>
    );
}

Example of using useState and useEffect together:
import React, { useState, useEffect } from 'react';
function Timer() {
    const [seconds, setSeconds] = useState(0);

    useEffect(() => {
        const interval = setInterval(() => {
            setSeconds(prevSeconds => prevSeconds + 1);
        }, 1000);
        return () => clearInterval(interval); // Cleanup on unmount
    }, []); // Empty dependency array means this effect runs once on mount

    return <div>Seconds: {seconds}</div>;
}
------------------------------------------------------------------------------------------

Forms in React:
In React, forms are typically handled using controlled components, where the form data is managed by the
component's state. This allows for more control over the form inputs and makes it easier to handle user input and form submission.
Example of a controlled form component:
import React, { useState } from 'react';
function MyForm() {
    const [name, setName] = useState('');

    const handleSubmit = (event) => {
        event.preventDefault();
        alert(`Submitted name: ${name}`);
    };

    return (
        <form onSubmit={handleSubmit}>
            <label>
                Name:
                <input
                    type="text"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                />
            </label>
            <button type="submit">Submit</button>
        </form>
    );
}
In this example, the input field is a controlled component because its value is controlled by the React state (the "name" variable). The onChange event updates the state whenever the user types in the input field, and the handleSubmit function is called when the form is submitted, preventing the default form submission behavior and displaying an alert with the submitted name.
----------------------------------------------------------------------------------------------------------------


Task: //Create Form in React-------------------- use local storage of browser
-------------------------------------------------------------------------


=============================================
Fetch Method in React using fetch() without useEffect:
=============================================

The fetch() method is a built-in JavaScript function that allows you to make network requests to retrieve resources from a server. In React, you can use the fetch() 
method to fetch data from an API and update your component's state with the retrieved data.
Example of using fetch() in a React component:
import React, { useState } from 'react';
function DataFetcher() {
    const [data, setData] = useState(null);

    const fetchData = () => {
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data))
            .catch(error => console.error('Error fetching data:', error));
    };

    return (
        <div>
            <button onClick={fetchData}>Fetch Data</button>
            {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
        </div>
    );
}

In this example, the fetchData function is called when the "Fetch Data" button is clicked. It uses the fetch() method to make a GET request to the specified API endpoint.
The response is then converted to JSON and stored in the component's state using setData. If there is an error during the fetch operation, it is caught and logged to the console.
The retrieved data is displayed in a formatted manner using JSON.stringify when it is available.


==========================
Adding Data---------
==========================
import React, { useState } from 'react';
function AddData() {
    const [name, setName] = useState('');
    const [age, setAge] = useState('');

    const handleSubmit = (event) => {
        event.preventDefault();
        const newData = { name, age };
        // Here you can send newData to an API or update your state
        console.log('New Data:', newData);
    };

    return (
        <form onSubmit={handleSubmit}>
            <label>
                Name:
                <input
                    type="text"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                />
            </label>
            <br />
            <label>
                Age:
                <input
                    type="number"
                    value={age}
                    onChange={(e) => setAge(e.target.value)}
                />
            </label>
            <br />
            <button type="submit">Add Data</button>
        </form>
    );
}

In this example, we have a form with two input fields for "name" and "age". The handleSubmit function is called when the form is submitted,
preventing the default form submission behavior.
It creates a new data object with the values from the input fields and logs it to the console.
You can modify the handleSubmit function to send this data to an API or update your component's state as needed.
----------------------------------------------------------------------------------------------------------------------------------

=======================================================================
Axios in React:
=======================================================================

Axios is a popular JavaScript library used for making HTTP requests from the browser. It provides a simple and intuitive API for sending asynchronous requests to a server and handling responses.
Example of using Axios in a React component:
import React, { useState } from 'react';
import axios from 'axios';
function DataFetcher() {
    const [data, setData] = useState(null);

    const fetchData = () => {
        axios.get('https://api.example.com/data')
            .then(response => setData(response.data))
            .catch(error => console.error('Error fetching data:', error));
    };

    return (
        <div>
            <button onClick={fetchData}>Fetch Data</button>
            {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
        </div>
    );
}
In this example, we import the Axios library and use it to make a GET request to the specified API endpoint when the "Fetch Data" button is clicked.
The response data is stored in the component's state using setData, and any errors during the request are caught and logged to the console. The retrieved data is displayed in a formatted manner using JSON.stringify when it is available.

Example of using Axios to send a POST request:
import React, { useState } from 'react';
import axios from 'axios';
function AddData() {
    const [name, setName] = useState('');
    const [age, setAge] = useState('');

    const handleSubmit = (event) => {
        event.preventDefault();
        const newData = { name, age };
        axios.post('https://api.example.com/data', newData)
            .then(response => console.log('Data added:', response.data))
            .catch(error => console.error('Error adding data:', error));
    };

    return (
        <form onSubmit={handleSubmit}>
            <label>
                Name:
                <input
                    type="text"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                />
            </label>
            <br />
            <label>
                Age:
                <input
                    type="number"
                    value={age}
                    onChange={(e) => setAge(e.target.value)}
                />
            </label>
            <br />
            <button type="submit">Add Data</button>
        </form>
    );
}

In this example, we use Axios to send a POST request to the specified API endpoint with the new data object when the form is submitted.
The response from the server is logged to the console, and any errors during the request are also caught and logged.

-----------------------------------------------------------------------------------------------------------------------------------

=====================================================================
Lifecycle Methods in React:
=====================================================================

Lifecycle methods are special methods in React class components that allow you to hook into different stages of a component's lifecycle, such as when
it is mounted, updated, or unmounted. These methods provide a way to perform side effects, manage state, and interact with the DOM at specific points in the component's lifecycle.

Some commonly used lifecycle methods include:
1. componentDidMount: Called immediately after a component is mounted (inserted into the tree).
    You can use this method to perform initialization tasks, such as fetching data from an API or setting up event listeners.

2. componentDidUpdate: Called immediately after updating occurs. This method is not called for the initial render.
    You can use this method to perform operations after the component has been updated, such as updating the DOM or making additional API calls based on changes in props or state.

3. componentWillUnmount: Called immediately before a component is unmounted and destroyed.
    You can use this method to perform cleanup tasks, such as removing event listeners or canceling network requests.

    Example of using lifecycle methods in a React class component:
    import React, { Component } from 'react';
    class MyComponent extends Component {
        componentDidMount() {
            console.log('Component has mounted');
            // Perform initialization tasks here
        }

        componentDidUpdate(prevProps, prevState) {
            console.log('Component has updated');
            // Perform operations after the component has been updated
        }

        componentWillUnmount() {
            console.log('Component will unmount');
            // Perform cleanup tasks here
        }

        render() {
            return <div>Hello, World!</div>;
        }
    }

In this example, we define a class component called MyComponent that implements the three lifecycle methods: componentDidMount, componentDidUpdate, and componentWillUnmount.

---------------------------------------------------------------------------------------------------




















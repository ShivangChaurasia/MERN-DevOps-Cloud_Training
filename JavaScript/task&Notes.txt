Task:
   Portfolio
   Blog App
   Form










Notes:
JavaScript is a dynamically typed programming language, meaning variable
types are determined at runtime and a variable can hold values of different
data types without explicit type declaration.
==================================================
        THE STORY BEHIND JAVASCRIPT
            (Complete History)
==================================================

--------------------------------------------------
1. THE WEB BEFORE JAVASCRIPT (Early 1990s)
--------------------------------------------------

â€¢ The web was completely static
â€¢ Websites were built using only HTML and CSS
â€¢ No interactivity
â€¢ No dynamic content
â€¢ Buttons did not react
â€¢ Every user action required a server request

Example:
Clicking a button â†’ Server request â†’ Full page reload

Result:
The web felt like online documents, not applications.

--------------------------------------------------
2. THE PROBLEM
--------------------------------------------------

Companies needed:
â€¢ Interactive forms
â€¢ Input validation before sending data to server
â€¢ Faster user experience
â€¢ Reduced server load

Conclusion:
Something was needed that could run directly
inside the browser.

--------------------------------------------------
3. BIRTH OF JAVASCRIPT (1995)
--------------------------------------------------

Creator:
â€¢ Brendan Eich
â€¢ Worked at Netscape Communications

Important Fact:
â€¢ JavaScript was created in just 10 days

Original Names:
â€¢ Mocha (internal name)
â€¢ LiveScript
â€¢ JavaScript (final name)

Why the name "JavaScript"?
â€¢ Java was extremely popular at that time
â€¢ The name was chosen mainly for marketing

Note:
JavaScript and Java are completely different languages.

--------------------------------------------------
4. ORIGINAL GOAL OF JAVASCRIPT
--------------------------------------------------

â€¢ Run inside the browser
â€¢ Add basic interactivity
â€¢ Validate forms
â€¢ Manipulate HTML elements

At that time:
â€¢ JavaScript was considered a small scripting language
â€¢ Not designed for large applications

--------------------------------------------------
5. BROWSER WARS (Midâ€“Late 1990s)
--------------------------------------------------

Netscape vs Microsoft (Internet Explorer)

â€¢ Netscape had JavaScript
â€¢ Microsoft created its own version called JScript

Problem:
â€¢ Different implementations in different browsers
â€¢ Same code behaved differently

Result:
â€¢ Developer frustration
â€¢ Unreliable behavior

--------------------------------------------------
6. STANDARDIZATION â€“ ECMASCRIPT (1997)
--------------------------------------------------

To solve browser inconsistency:
â€¢ JavaScript was standardized by ECMA International
â€¢ Official standard name: ECMAScript

Important:
â€¢ JavaScript is an implementation of ECMAScript

Version naming:
â€¢ ES5
â€¢ ES6 (ES2015)
â€¢ ES2020 and beyond

--------------------------------------------------
7. THE DARK AGE OF JAVASCRIPT (Early 2000s)
--------------------------------------------------

â€¢ JavaScript was slow
â€¢ Used mainly for:
  - Form validation
  - Simple animations
â€¢ Considered a "toy language"

Serious applications were built using:
â€¢ Java Applets
â€¢ Flash
â€¢ Silverlight

--------------------------------------------------
8. THE AJAX REVOLUTION (2005)
--------------------------------------------------

AJAX:
â€¢ Asynchronous JavaScript and XML

Popularized by:
â€¢ Google Maps
â€¢ Gmail

What changed?
â€¢ Pages could update without reloading
â€¢ Smooth, app-like experience

Impact:
â€¢ JavaScript proved it could power real applications

--------------------------------------------------
9. PERFORMANCE BOOST â€“ V8 ENGINE (2008)
--------------------------------------------------

Google Chrome:
â€¢ Introduced the V8 JavaScript Engine

V8 Features:
â€¢ Extremely fast
â€¢ Compiles JavaScript to machine code

Result:
â€¢ Massive performance improvement
â€¢ JavaScript was no longer slow

--------------------------------------------------
10. NODE.JS â€“ JAVASCRIPT OUTSIDE THE BROWSER (2009)
--------------------------------------------------

Creator:
â€¢ Ryan Dahl

What changed?
â€¢ JavaScript could now run on servers

Impact:
â€¢ Same language for frontend and backend
â€¢ Birth of full-stack JavaScript

Examples:
â€¢ Express.js
â€¢ MERN Stack
â€¢ MEAN Stack

--------------------------------------------------
11. RISE OF FRAMEWORKS & LIBRARIES (2010â€“2015)
--------------------------------------------------

To manage growing complexity:
â€¢ jQuery â€“ simplified DOM manipulation
â€¢ AngularJS â€“ full MVC framework
â€¢ React (2013) â€“ component-based UI
â€¢ Vue.js â€“ lightweight alternative

JavaScript became the center of web development.

--------------------------------------------------
12. ES6 / ES2015 â€“ MODERN JAVASCRIPT
--------------------------------------------------

Major features introduced:
â€¢ let, const
â€¢ Arrow functions
â€¢ Classes
â€¢ Modules
â€¢ Promises
â€¢ Destructuring
â€¢ Spread operator

Result:
â€¢ Cleaner syntax
â€¢ More powerful language
â€¢ Suitable for large-scale applications

--------------------------------------------------
13. JAVASCRIPT EVERYWHERE (2016â€“Present)
--------------------------------------------------

JavaScript now runs on:
â€¢ Browsers
â€¢ Servers (Node.js)
â€¢ Mobile apps (React Native)
â€¢ Desktop apps (Electron)
â€¢ IoT devices
â€¢ Cloud functions
â€¢ AI tooling and automation

--------------------------------------------------
14. CURRENT STATUS OF JAVASCRIPT
--------------------------------------------------

â€¢ One of the most popular programming languages
â€¢ Backbone of:
  - Web development
  - Full stack development
  - Cloud and DevOps tooling

From a 10-day scripting experiment
to a world-dominating language.

==================================================
        JAVASCRIPT DATA TYPES
==================================================

--------------------------------------------------
15. PRIMITIVE DATA TYPES
--------------------------------------------------

Primitive data types store a single value
and are immutable.

1. String
   Example: "Hello"

2. Number
   Example: 10, 3.14

3. BigInt
   Example: 123456789n

4. Boolean
   Example: true, false

5. Undefined
   Example: undefined

6. Null
   Example: null

7. Symbol
   Example: Symbol("id")

--------------------------------------------------
16. NON-PRIMITIVE (REFERENCE) DATA TYPES
--------------------------------------------------

Non-primitive data types store references
and can hold multiple values.

1. Object
   Example: { name: "Shivang", age: 21 }

2. Array
   Example: [1, 2, 3]

3. Function
   Example: function greet() {}

4. Date
   Example: new Date()

5. RegExp
   Example: /abc/



-------------------------------------------------------
Data Types
--------------------------------------------------------

var:
    var firstname; //Declaration
    firstname = "Shivang";  //Assignment
    firstname = "secName"; //Re-Assignment
    var firstname = "ThirdName"; //Re-Declaration
    All Possible in var


let:
    let name; //Declaration Possible
    name = "Shivang"; //Assignment Possible
    name = "Chaurasia"; //Re-Assignment Possible
    let name= "234321"; // X Not Possible

const:
    const name = "Shivang"; //You can't declare const without passing some value.




--------------------------------------------------
1. ARRAYS IN JAVASCRIPT
--------------------------------------------------

â€¢ Arrays store multiple values in a single variable
â€¢ Arrays are zero-indexed
â€¢ typeof array returns "object"

Example:
let arr = [10, 20, 30, 40, 50];

Important Properties & Methods:
â€¢ arr.length â†’ number of elements
â€¢ arr.push() â†’ add element at end
â€¢ arr.pop() â†’ remove last element
â€¢ arr.unshift() â†’ add element at start
â€¢ arr.shift() â†’ remove first element
â€¢ arr.indexOf() â†’ find index
â€¢ arr.splice() â†’ add/remove elements
â€¢ arr.slice() â†’ extract portion (new array)
â€¢ arr.reverse() â†’ reverse array
â€¢ arr.sort() â†’ sort array

--------------------------------------------------
2. MIXED (HETEROGENEOUS) ARRAYS
--------------------------------------------------

â€¢ JavaScript arrays can store different data types
â€¢ Arrays can contain:
  - numbers
  - strings
  - booleans
  - objects
  - arrays

Example:
[1, "apple", true, 5.6, {}, []]

--------------------------------------------------
3. ARRAY DESTRUCTURING
--------------------------------------------------

â€¢ Used to extract values from arrays
â€¢ Order matters

Example:
let [a, b, c] = arr;

--------------------------------------------------
4. OBJECTS IN JAVASCRIPT
--------------------------------------------------

â€¢ Objects store data in key-value pairs
â€¢ Keys are strings, values can be any type

Example:
{
  name: "Alice",
  age: 20,
  isEnrolled: true
}

Accessing:
â€¢ object.key
â€¢ object["key"]

--------------------------------------------------
5. LOOPS
--------------------------------------------------



for...in
â€¢ Used for objects
â€¢ Iterates over keys

   let person = { name: "John", age: 25, city: "Delhi" };

   for (let key in person) {
       console.log(key + ": " + person[key]);
   }

for...of
â€¢ Used for arrays
â€¢ Iterates over values

   let colors = ["Red", "Green", "Blue"];

   for (let color of colors) {
       console.log(color);
   }


--------------------------------------------------
6. DATA TYPES IN JAVASCRIPT
--------------------------------------------------

JavaScript has two types of data types:

--------------------
A. Primitive Types
--------------------

â€¢ Number â†’ numeric values
â€¢ String â†’ text
â€¢ Boolean â†’ true / false
â€¢ Undefined â†’ variable declared but not assigned
â€¢ Null â†’ intentional empty value
â€¢ Symbol â†’ unique identifier
â€¢ BigInt â†’ very large integers

Primitive types store a single value.

------------------------
B. Non-Primitive Types
------------------------

â€¢ Object â†’ collection of key-value pairs
â€¢ Array â†’ ordered collection
â€¢ Function â†’ block of reusable code
â€¢ Date â†’ date and time
â€¢ RegExp â†’ pattern matching

Non-primitive types store references.

--------------------------------------------------
7. typeof OPERATOR
--------------------------------------------------

â€¢ Used to find the type of a value
â€¢ typeof null returns "object" (JS bug)

--------------------------------------------------
8. FUNCTIONS
--------------------------------------------------

â€¢ Functions are reusable blocks of code
â€¢ They can accept parameters
â€¢ They can return values

Example:
function sum(a, b) {
  return a + b;
}

--------------------------------------------------
9. NUMBER METHODS
--------------------------------------------------

â€¢ toFixed() â†’ decimal places
â€¢ toPrecision() â†’ total digits

--------------------------------------------------
10. STRING METHODS
--------------------------------------------------

â€¢ length â†’ string size
â€¢ toUpperCase() â†’ uppercase
â€¢ toLowerCase() â†’ lowercase
â€¢ indexOf() â†’ position
â€¢ slice() â†’ extract part
â€¢ replace() â†’ replace text
â€¢ split() â†’ string to array
â€¢ includes() â†’ check existence
â€¢ trim() â†’ remove spaces

--------------------------------------------------
11. MATH OBJECT
--------------------------------------------------

â€¢ Math.abs() â†’ absolute value
â€¢ Math.ceil() â†’ round up
â€¢ Math.floor() â†’ round down
â€¢ Math.round() â†’ nearest integer
â€¢ Math.random() â†’ random number
â€¢ Math.max() / Math.min()
â€¢ Math.sqrt() â†’ square root
â€¢ Math.pow() â†’ power

--------------------------------------------------
12. DATE OBJECT
--------------------------------------------------

â€¢ new Date() â†’ current date & time
â€¢ getFullYear()
â€¢ getMonth()
â€¢ getDate()
â€¢ getDay()
â€¢ getHours()
â€¢ getMinutes()
â€¢ getSeconds()
â€¢ getTime()

--------------------------------------------------
13. CONDITIONAL STATEMENTS
--------------------------------------------------

â€¢ if
â€¢ if-else
â€¢ else-if
â€¢ nested if
â€¢ switch-case
â€¢ ternary operator (? :)

--------------------------------------------------
14. LOOPS
--------------------------------------------------

â€¢ for loop â†’ fixed iterations
â€¢ while loop â†’ condition-based
â€¢ do-while loop â†’ runs at least once

--------------------------------------------------
15. REST OPERATOR (...)
--------------------------------------------------

â€¢ Collects multiple values into an array
â€¢ Used in functions

Example:
function sum(...nums) {}

--------------------------------------------------
16. SPREAD OPERATOR (...)
--------------------------------------------------

â€¢ Expands values
â€¢ Used with arrays & objects
â€¢ Copies data

Example:
let newArr = [...arr1, ...arr2];

--------------------------------------------------
17. ARRAY METHODS (IMPORTANT)
--------------------------------------------------

â€¢ forEach() â†’ iterate
â€¢ map() â†’ transform
â€¢ filter() â†’ condition-based selection
â€¢ reduce() â†’ accumulate values

--------------------------------------------------
18. ARROW FUNCTIONS
--------------------------------------------------

â€¢ Shorter function syntax
â€¢ Uses =>

Example:
const add = (a, b) => a + b;

--------------------------------------------------
19. REAL-WORLD FILTER EXAMPLE
--------------------------------------------------

â€¢ filter() is used to extract data
â€¢ Useful in real applications

Example:
Filter people from a specific city



-----------------------------------------

There are 6 falsey values:
null
undefined
""
0
false
NAn


-------------------------------------------------

What is Coersion in JavaScript?
   Type Coersion is the automatic or implicit conversion of values
   from one data type to another (such as strings to numbers).
   In JavaScript, this often happens during operations involving
   different data types.

   Example:
   let result = '5' + 10; // '510' (number 10 is coerced to string)
----------------------------------

Call by Value vs Call by Reference using Primitive and Non-Primitive Data Types:

   Call by Value:
       When a primitive data type (like number, string, boolean)
       is passed to a function, a copy of the value is made.
       Changes made to the parameter inside the function do not
       affect the original variable.

   Call by Reference:
       When a non-primitive data type (like object, array)
       is passed to a function, a reference to the original
       object is passed. Changes made to the parameter inside
       the function will affect the original object.

       Example:
         function modifyArray(arr) {
            arr.push(4);
         }
         let myArray = [1, 2, 3];
         modifyArray(myArray);
         console.log(myArray); // Output: [1, 2, 3, 4] This is Call by Reference

         let a = 20;
          console.log(a);
          let b= a;
          console.log(b);
          console.log(a);
          b=30;
          console.log(b);
          console.log(a); //In primitive a will not be updated by the infulence of b
---------------------------------------------------------

Object Destructuring:

   Object destructuring is a syntax that allows you to extract
   properties from an object and assign them to variables
   in a more concise way.

   Example:
     const person = {
        name: "Shivang",
        age: 21,
        city: "Delhi"
     };

     // Traditional way
     const name = person.name;
     const age = person.age;
     const city = person.city;

     // Using object destructuring
     const { name, age, city } = person;

     console.log(name); // Output: Shivang
     console.log(age);  // Output: 21
     console.log(city); // Output: Delhi


-------------------

Spread Operator with Objects:

   The spread operator (...) allows you to create a new object
   by copying properties from an existing object.

   Example:
     const original = {
        name: "Shivang",
        age: 21
     };

     const copy = { ...original, city: "Delhi" };

     console.log(copy);
     // Output: { name: "Shivang", age: 21, city: "Delhi" }

-------------------
Rest Operator with Objects:

   The rest operator (...) allows you to collect the remaining
   properties of an object into a new object.

   Example:
     const person = {
        name: "Shivang",
        age: 21,
        city: "Delhi"
     };

     const { name, ...rest } = person;

     console.log(name); // Output: Shivang
     console.log(rest); // Output: { age: 21, city: "Delhi" }

------------------------
Option Chaining (?.):

   Option chaining is a syntax that allows you to safely access
   nested properties of an object without causing an error
   if a property is undefined or null.

   Example:
     const person = {
        name: "Shivang",
        address: {
           city: "Delhi"
        }
     };

     // Accessing nested property safely
     const city = person.address?.city;
     console.log(city); // Output: Delhi

     // If address is undefined
     const person2 = {
        name: "Ravi"
     };

     const city2 = person2.address?.city;
     console.log(city2); // Output: undefined (no error)

--------------------------------------------------

   What is High Order Function in JavaScript?
   A higher-order function is a function that either takes one or more functions as arguments or returns a function as its result.
   Example:
     // Function that takes another function as an argument
     function greet(name, formatter) {
        return "Hello, " + formatter(name);
     }

     function upperCaseName(name) {
        return name.toUpperCase();
     }

     console.log(greet("Shivang", upperCaseName)); // Output: Hello, SHIVANG

     // Function that returns another function
     function multiplier(factor) {
        return function(number) {
           return number * factor;
        };
     }

     const double = multiplier(2);
     console.log(double(5)); // Output: 10

--------------------------------------------------

How does array.map work?

   The map() method creates a new array populated with the results
   of calling a provided function on every element in the calling array.


   Syntax:
     array.map(function(currentValue, index, array) {
        // Return element for new array
     });

   Example:
     const numbers = [1, 2, 3, 4];
     const doubled = numbers.map(function(num) {
        return num * 2;
     });

     console.log(doubled); // Output: [2, 4, 6, 8]

   Using Arrow Function:
     const doubledArrow = numbers.map(num => num * 2);
     console.log(doubledArrow); // Output: [2, 4, 6, 8]

Filter Method in JavaScript:

   The filter() method creates a new array with all elements
   that pass the test implemented by the provided function.

   Syntax:
     array.filter(function(currentValue, index, array) {
        // Return true to keep the element, false otherwise
     });

   Example:
     const numbers = [1, 2, 3, 4, 5];
     const evenNumbers = numbers.filter(function(num) {
        return num % 2 === 0;
     });

     console.log(evenNumbers); // Output: [2, 4]

   Using Arrow Function:
     const evenNumbersArrow = numbers.filter(num => num % 2 === 0);
     console.log(evenNumbersArrow); // Output: [2, 4]


Reduce Method in JavaScript:

   The reduce() method executes a reducer function
   on each element of the array, resulting in a single output value.

   Syntax:
     array.reduce(function(accumulator, currentValue, index, array) {
        // Return the updated accumulator
     }, initialValue);

   Example:
     const numbers = [1, 2, 3, 4];
     const sum = numbers.reduce(function(accumulator, num) {
        return accumulator + num;
     }, 0);

     console.log(sum); // Output: 10

   Using Arrow Function:
     const sumArrow = numbers.reduce((accumulator, num) => accumulator + num, 0);
     console.log(sumArrow); // Output: 10

------------------------------------------------------


// =======================================================================
    // Data Object Model : DOM Manipulation
// =======================================================================
Refer javaScript.js



// =======================================================================
    // Events in JavaScript
// =======================================================================

Event Bubbling:
   Event bubbling is a type of event propagation in the HTML DOM
   where the event starts from the deepest target element
   and then bubbles up to its parent elements.

   Example:
     <div id="parent">
        <button id="child">Click Me</button>
     </div>

     <script>
        document.getElementById("child").addEventListener("click", function() {
           alert("Child Clicked");
        });

        document.getElementById("parent").addEventListener("click", function() {
           alert("Parent Clicked");
        });
     </script>

   When you click the button, the alert for "Child Clicked"
   will show first, followed by "Parent Clicked".
------------------------------------------
Event Capturing:
   Event capturing is another type of event propagation in the HTML DOM
   where the event starts from the outermost element and then moves down to the target element.

   Example:
     <div id="parent">
        <button id="child">Click Me</button>
     </div>
       <script>
         document.getElementById("parent").addEventListener("click", function() {
             alert("Parent Clicked");
         }, true); // true for capturing
   
         document.getElementById("child").addEventListener("click", function() {
             alert("Child Clicked");
         }, true); // true for Capturing
         </script>
   When you click the button, the alert for "Parent Clicked"
   will show first, followed by "Child Clicked".
-----------------------------------------------
Event Delegation:
   Event delegation is a technique in JavaScript
   where a single event listener is added to a parent element
   and handles events for its child elements.

   Example:
     <ul id="itemList">
        <li>Item 1</li>
        <li>Item 2</li>
        <li>Item 3</li>
     </ul>

     <script>
        document.getElementById("itemList").addEventListener("click", function(event) {
           if (event.target && event.target.nodeName === "LI") {
              alert("You clicked on " + event.target.innerText);
           }
        });
     </script>

   When you click on any list item, the alert will show the text of the clicked item.
------------------------------------------------------

Scope in JavaScript:

   Scope in JavaScript refers to the current context of code,
   which determines the accessibility of variables and functions.

   Types of Scope:
     1. Global Scope:
        Variables declared outside any function
        are in the global scope and accessible from anywhere.

     2. Local Scope:
        Variables declared within a function
        are in the local scope and accessible only within that function.

     3. Block Scope:
        Variables declared with let or const
        inside a block (e.g., inside { }) are in block scope
        and accessible only within that block.

   Example:
     var globalVar = "I am global";

     function myFunction() {
        var localVar = "I am local";
        if (true) {
           let blockVar = "I am block scoped";
           console.log(blockVar); // Accessible here
        }
        console.log(localVar); // Accessible here
        // console.log(blockVar); // Not accessible here (Error)
     }

     myFunction();
     console.log(globalVar); // Accessible here
     // console.log(localVar); // Not accessible here (Error)
------------------------------------------------------

Closures in JavaScript:

   A closure is a function that retains access to its lexical scope,
   even when the function is executed outside that scope.

   Example:
     function outerFunction(outerVariable) {
        return function innerFunction(innerVariable) {
           console.log("Outer Variable: " + outerVariable);
           console.log("Inner Variable: " + innerVariable);
        };
     }

     const newFunction = outerFunction("outside");
     newFunction("inside");

   Output:
     Outer Variable: outside
     Inner Variable: inside

   In this example, innerFunction forms a closure
   that captures the variable outerVariable from its outer scope.

------------------------------------------------------


Lexical Scope in JavaScript:

   Lexical scope means that the accessibility of variables
   is determined by the physical structure of the code
   (where the variables are declared).

   Example:
     function outerFunction() {
        var outerVar = "I am outside";

        function innerFunction() {
           console.log(outerVar); // Accessible due to lexical scope
        }

        innerFunction();
     }

     outerFunction();

   In this example, innerFunction can access outerVar
   because it is defined within the lexical scope of outerFunction.



============================================================
HOISTING IN JAVASCRIPT
============================================================

1. Hoisting is a JavaScript mechanism where variable and function
declarations are moved to the top of their containing scope
during the compilation phase before code execution.

2. This means that you can use variables and functions
before they are declared in the code.

3. However, only the declarations are hoisted, not the initializations.
Example 1: Variable Hoisting with var

   console.log(myVar); // Output: undefined (not ReferenceError)
   var myVar = 10;
   console.log(myVar); // Output: 10

   // Behind the scenes, JavaScript interprets it as:
   var myVar; // Declaration hoisted
   console.log(myVar); // undefined
   myVar = 10; // Initialization
   console.log(myVar); // 10

Example 2: Function Hoisting
   greet(); // Output: "Hello, World!"

   function greet() {
      console.log("Hello, World!");
   }

   // Behind the scenes, JavaScript interprets it as:
   function greet() {
      console.log("Hello, World!");
   }
   greet(); // "Hello, World!"

Example 3: let and const Hoisting
   console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
   let myLet = 20;
   console.log(myLet); // Output: 20
   // Behind the scenes, JavaScript interprets it as:
   let myLet; // Declaration hoisted but not initialized

   console.log(myConst); // ReferenceError: Cannot access 'myConst' before initialization
   const myConst = 30;
   console.log(myConst); // Output: 30
   // Behind the scenes, JavaScript interprets it as:
   const myConst; // Declaration hoisted but not initialized

Example 4: Function Expressions
   greetExpr(); // TypeError: greetExpr is not a function

   var greetExpr = function() {
      console.log("Hello from function expression!");
   };

   // Behind the scenes, JavaScript interprets it as:
   var greetExpr; // Declaration hoisted
   greetExpr(); // TypeError: greetExpr is not a function
   greetExpr = function() {
      console.log("Hello from function expression!");
   };

Example 5: Arrow Functions
   greetArrow(); // TypeError: greetArrow is not a function

   const greetArrow = () => {
      console.log("Hello from arrow function!");
   };

   // Behind the scenes, JavaScript interprets it as:
   const greetArrow; // Declaration hoisted but not initialized
   greetArrow(); // TypeError: greetArrow is not a function
   greetArrow = () => {
      console.log("Hello from arrow function!");
   };

Comparison Table:
| Declaration Type     | Hoisted?          | Initial Value Before Declaration | Error if Accessed Before Declaration |
|----------------------|-------------------|----------------------------------|--------------------------------------|
| var                  | Yes               | undefined                        | No                                   |
| let                  | Yes               | Not initialized                  | Yes (ReferenceError)                 |
| const                | Yes               | Not initialized                  | Yes (ReferenceError)                 |
| Function Declaration | Yes               | N/A                              | No                                   |
| Function Expression  | Yes (var only)    | undefined (var)                  | Yes (TypeError)                      |

Temporal Dead Zone (TDZ):
   The TDZ is the time between entering a scope
   and the point where a variable declared with let or const
   is initialized. Accessing the variable in this zone
   results in a ReferenceError.
   Example:
     {
        console.log(myLet); // ReferenceError
        let myLet = 10;
     }

4. In summary, hoisting allows functions and var-declared variables
to be used before their declaration, but let and const variables are not initialized until their declaration is reached, hence they throw a ReferenceError if accessed before initialization.
============================================================

Context Binding
   Context binding in JavaScript refers to the way the value of 'this'
   is determined within functions and methods.

   1. Global Context:
      In the global scope, 'this' refers to the global object
      (window in browsers, global in Node.js).

      Example:
        console.log(this); // In browser: Window object

   2. Function Context:
      In a regular function, 'this' refers to the global object
      (in non-strict mode) or undefined (in strict mode).

      Example:
        function showThis() {
           console.log(this);
        }
        showThis(); // In browser: Window object (non-strict mode)

   3. Method Context:
      When a function is called as a method of an object,
      'this' refers to the object itself.

      Example:
        const obj = {
           name: "Shivang",
           greet: function() {
              console.log(this.name);
           }
        };
        obj.greet(); // Output: Shivang

   4. Constructor Context:
      In a constructor function, 'this' refers to the newly created object.

      Example:
        function Person(name) {
           this.name = name;
        }
        const person1 = new Person("Ravi");
        console.log(person1.name); // Output: Ravi

   5. Explicit Binding:
      You can explicitly set the value of 'this' using call(), apply(), or bind().

      Example:
        function greet() {
           console.log(this.name);
        }
        const person = { name: "Anita" };
        greet.call(person); // Output: Anita

   6. Arrow Functions:
      Arrow functions do not have their own 'this'.
      They inherit 'this' from the surrounding lexical context.

      Example:
        const obj = {
           name: "Shivang",
           greet: () => {
              console.log(this.name);
           }
        };
        obj.greet(); // Output: undefined (or global object's name)

   In summary, context binding determines what 'this' refers to
   based on how a function is called.

----------------------------------------------------------------------------------------------
============================================================================================
// Synchronus JavaScript vs Asynchronus JavaScript
============================================================================================

1. Synchronous JavaScript:
   - Executes code sequentially, one line at a time.
   - Each operation must complete before the next one starts.
   - If a task takes a long time, it blocks the execution of subsequent code.
   - Example: Simple calculations, loops.

   Example:
     console.log("Start");
     for (let i = 0; i < 1e9; i++) {} // Long loop
     console.log("End");

   Output:
     Start
     (long delay)
     End

2. Asynchronous JavaScript:
   - Allows multiple operations to run concurrently.
   - Tasks can start before previous ones finish.
   - Uses callbacks, promises, or async/await to handle operations that take time.
   - Non-blocking; other code can run while waiting for an operation to complete.
   - Example: Network requests, timers.
   Example:
     console.log("Start");
     setTimeout(() => {
        console.log("Async Task Complete");
     }, 2000);
     console.log("End");
   Output:
     Start
     End
     (after 2 seconds)
     Async Task Complete

3. Key Differences:
--------------------------------------------------------------------------------------------
| Aspect               | Synchronous JavaScript          | Asynchronous JavaScript         |
|----------------------|---------------------------------|---------------------------------|
| Execution            | Sequential                      | Concurrent                      |
| Blocking             | Yes                             | No                              |
| Use Cases            | Simple tasks, calculations      | Network requests, timers        |
| Handling Delays      | Blocks execution                | Uses callbacks/promises/async   |
| Complexity           | Simpler to understand           | More complex due to concurrency  |
---------------------------------------------------------------------------------------------

4. Conclusion:
   - Synchronous JavaScript is straightforward but can lead to performance issues.
   - Asynchronous JavaScript improves responsiveness and efficiency,
     especially for I/O-bound operations.
   - Modern JavaScript heavily relies on asynchronous patterns
     to create smooth user experiences.
-----------------------------------------------------------------------------------------------
=======================================================================================
ðŸ” setTimeout vs ðŸ”„ setInterval
=======================================================================================

1. setTimeout:
   - Executes a function once after a specified delay (in milliseconds).
   - Syntax: setTimeout(function, delay);
   - Use Case: When you want to run a function after a certain period of time.

   Example:
     setTimeout(() => {
        console.log("This runs after 2 seconds");
     }, 2000);

2. setInterval:
   - Executes a function repeatedly at specified intervals (in milliseconds).
   - Syntax: setInterval(function, interval);
   - Use Case: When you want to run a function repeatedly at regular intervals.
   Example:
     setInterval(() => {
        console.log("This runs every 2 seconds");
     }, 2000);

3. Key Differences:
-------------------------------------------------------------------------------------------
| Aspect            | setTimeout                      | setInterval                     |
|-------------------|---------------------------------|---------------------------------|
| Execution         | Runs once after delay           | Runs repeatedly at intervals     |
| Syntax            | setTimeout(function, delay)     | setInterval(function, interval)  |
| Use Case          | Delayed execution                | Repeated execution               |
| Stopping          | clearTimeout(timeoutID)         | clearInterval(intervalID)        |
-------------------------------------------------------------------------------------------

4. Stopping Execution:
   - You can stop a setTimeout using clearTimeout(timeoutID).
   - You can stop a setInterval using clearInterval(intervalID).
   Example:
     const timeoutID = setTimeout(() => {
        console.log("This will not run");
     }, 2000);
     clearTimeout(timeoutID); // Stops the timeout

     const intervalID = setInterval(() => {
        console.log("This will run every 2 seconds");
     }, 2000);
     clearInterval(intervalID); // Stops the interval

5. Conclusion:
   - setTimeout is used for delayed execution of a single task.
   - setInterval is used for repeated execution of a task at regular intervals.
   - Both can be stopped using clearTimeout() and clearInterval() respectively.
   - Understanding these differences is crucial for managing asynchronous operations in JavaScript.
----------------------------------------------------------------------------------------------------------------

=============================================================================================
Promises in JavaScript
============================================================================================

1. What is a Promise?
   - A Promise is an object representing the eventual completion
     or failure of an asynchronous operation.
   - It allows you to handle asynchronous tasks more effectively.
   - A Promise can be in one of three states:
     - Pending: Initial state, neither fulfilled nor rejected.
     - Fulfilled: Operation completed successfully.
     - Rejected: Operation failed.
2. Creating a Promise:
   const myPromise = new Promise((resolve, reject) => {
      // Asynchronous operation
      let success = true; // Simulate success or failure
      if (success) {
         resolve("Operation Successful");
      } else {
         reject("Operation Failed");
      }
   });

3. Consuming a Promise
   myPromise
      .then((result) => {
         console.log(result); // Handle success
      })
      .catch((error) => {
         console.error(error); // Handle failure
      });

4. Chaining Promises:
   myPromise
      .then((result) => {
         console.log(result);
         return "Next Operation";
      })
      .then((nextResult) => {
         console.log(nextResult);
      })
      .catch((error) => {
         console.error(error);
      });

5. Promise.all:
   - Used to run multiple promises in parallel.
   const promise1 = Promise.resolve(3);
   const promise2 = 42;
   const promise3 = new Promise((resolve, reject) => {
      setTimeout(resolve, 100, 'foo');
   });
   Promise.all([promise1, promise2, promise3]).then((values) => {
      console.log(values); // [3, 42, "foo"]
   });
6. Conclusion:
   - Promises provide a cleaner way to handle asynchronous operations
     compared to traditional callbacks.
   - They help avoid "callback hell" and make code more readable.
   - Understanding Promises is essential for modern JavaScript development.
----------------------------------------------------------------------------------------------


































































































































































































































































































































































































































































































































































































